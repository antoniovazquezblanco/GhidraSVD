/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package svd.task;

import docking.widgets.OptionDialog;
import ghidra.framework.store.LockException;
import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressOverflowException;
import ghidra.program.model.address.AddressSpace;
import ghidra.program.model.listing.Program;
import ghidra.program.model.mem.Memory;
import ghidra.program.model.mem.MemoryBlock;
import ghidra.program.model.mem.MemoryConflictException;
import ghidra.util.Msg;
import ghidra.util.exception.CancelledException;
import ghidra.util.task.Task;
import ghidra.util.task.TaskMonitor;
import io.svdparser.SvdAddressBlock;
import io.svdparser.SvdDevice;
import io.svdparser.SvdPeripheral;
import svd.MemoryUtils;
import svd.MemoryUtils.MemRangeRelation;

public class SvdMemoryMapUpdateTask extends Task {
	private SvdDevice mSvdDevice;
	private Program mProgram;
	private Memory mMemory;

	public SvdMemoryMapUpdateTask(Program program, SvdDevice device) {
		super("Create SVD Memory Map Regions", true, false, true, true);
		mProgram = program;
		mMemory = program.getMemory();
		mSvdDevice = device;
	}

	@Override
	public void run(TaskMonitor monitor) throws CancelledException {
		// Process the blocks...
		monitor.setMessage("Processing memory blocks...");
		for (SvdPeripheral periph : mSvdDevice.getPeripherals()) {
			monitor.checkCancelled();
			processPeripheral(monitor, periph);
		}
	}

	private void processPeripheral(TaskMonitor monitor, SvdPeripheral periph) throws CancelledException {
		for (SvdAddressBlock block : periph.getAddressBlocks()) {
			monitor.checkCancelled();
			processPeripheralBlock(monitor, periph, block);
		}

	}

	private void processPeripheralBlock(TaskMonitor monitor, SvdPeripheral periph, SvdAddressBlock block) {
		String blockName = getPeriphBlockName(periph, block);
		long address = periph.getBaseAddr() + block.getOffset();
		long size = block.getSize();
		boolean isReadable = true;
		boolean isWritable = true;
		boolean isExecutable = blockName.contains("RAM") || blockName.contains("memory");
		boolean isVolatile = !isExecutable;

		processBlockMemory(blockName, isReadable, isWritable, isExecutable, isVolatile, address, size);
	}

	private String getPeriphBlockName(SvdPeripheral periph, SvdAddressBlock block) {
		String name = periph.getName();
		String blockUsage = block.getUsage();
		if (blockUsage != null && !blockUsage.isEmpty() && !blockUsage.contains("registers")) {
			name += "_" + blockUsage;
		}
		return name;
	}

	private boolean processBlockMemory(String name, boolean isReadable, boolean isWritable, boolean isExecutable,
			boolean isVolatile, long address, long size) {
		MemoryBlock[] collidingMemoryBlocks = MemoryUtils.getBlockCollidingMemoryBlocks(mMemory, address, size);
		if (collidingMemoryBlocks.length == 0) {
			createMemoryBlock(name, isReadable, isWritable, isExecutable, isVolatile, address, size);
		} else if (collidingMemoryBlocks.length == 1 && MemoryUtils.getMemoryBlockRelation(collidingMemoryBlocks[0],
				address, size) == MemRangeRelation.RANGES_ARE_EQUAL) {
			updateMatchingMemoryBlock(collidingMemoryBlocks[0], name, isReadable, isWritable, isExecutable, isVolatile);
		} else {
			Msg.showWarn(getClass(), null, "Load SVD",
					"Could not create a region for " + name + "@" + String.format("0x%08x", address) + "+"
							+ String.format("0x%08x", size) + ". It conflicts with an existing region!");
			return false;
		}
		return true;
	}

	private void createMemoryBlock(String name, boolean isReadable, boolean isWritable, boolean isExecutable,
			boolean isVolatile, long address, long size) {
		AddressSpace addrSpace = mProgram.getAddressFactory().getDefaultAddressSpace();
		Address addr = addrSpace.getAddress(address);
		int transactionId = mProgram.startTransaction("SVD memory block creation");
		boolean ok = false;
		try {
			MemoryBlock memBlock = mMemory.createUninitializedBlock(name, addr, size, false);
			memBlock.setRead(isReadable);
			memBlock.setWrite(isWritable);
			memBlock.setExecute(isExecutable);
			memBlock.setVolatile(isVolatile);
			memBlock.setComment("Generated by SVD");
			ok = true;
		} catch (LockException e) {
			Msg.showError(this, null, getTaskTitle(), e, e);
		} catch (MemoryConflictException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IllegalArgumentException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (AddressOverflowException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		mProgram.endTransaction(transactionId, ok);
	}

	private void updateMatchingMemoryBlock(MemoryBlock collidingMemoryBlock, String name, boolean isReadable,
			boolean isWritable, boolean isExecutable, boolean isVolatile) {
		if (!collidingMemoryBlock.getName().equals(name) && OptionDialog.showYesNoDialog(null, "Load SVD",
				"An existing memory block with name \"" + collidingMemoryBlock.getName()
						+ "\" is in the same region as the \"" + name + "\" peripheral. Do you want to rename it to \""
						+ name + "\"?") == OptionDialog.OPTION_ONE) {
			int transactionId = mProgram.startTransaction("SVD memory block rename");
			boolean ok = false;
			try {
				collidingMemoryBlock.setName(name);
				collidingMemoryBlock.setComment("Changed by SVD");
				ok = true;
			} catch (IllegalArgumentException | LockException e) {
				e.printStackTrace();
			}
			mProgram.endTransaction(transactionId, ok);
		}
		if (collidingMemoryBlock.isRead() != isReadable && OptionDialog.showYesNoDialog(null, "Load SVD",
				"Memory block \"" + collidingMemoryBlock.getName() + "\" is marked as"
						+ ((!collidingMemoryBlock.isRead()) ? " non" : "")
						+ " readable. The SVD file suggests it should be"
						+ (collidingMemoryBlock.isRead() ? " non" : "") + " readable. Do you want to change it to"
						+ (collidingMemoryBlock.isRead() ? " non" : "") + " readable?") == OptionDialog.OPTION_ONE) {
			int transactionId = mProgram
					.startTransaction("SVD " + collidingMemoryBlock.getName() + " memory block property change");
			boolean ok = false;
			try {
				collidingMemoryBlock.setRead(isReadable);
				collidingMemoryBlock.setComment("Changed by SVD");
				ok = true;
			} catch (IllegalArgumentException e) {
				e.printStackTrace();
			}
			mProgram.endTransaction(transactionId, ok);
		}

		if (collidingMemoryBlock.isWrite() != isWritable && OptionDialog.showYesNoDialog(null, "Load SVD",
				"Memory block \"" + collidingMemoryBlock.getName() + "\" is marked as"
						+ ((!collidingMemoryBlock.isWrite()) ? " non" : "")
						+ " writable. The SVD file suggests it should be"
						+ (collidingMemoryBlock.isWrite() ? " non" : "") + " writable. Do you want to change it to"
						+ (collidingMemoryBlock.isWrite() ? " non" : "") + " writable?") == OptionDialog.OPTION_ONE) {
			int transactionId = mProgram
					.startTransaction("SVD " + collidingMemoryBlock.getName() + " memory block property change");
			boolean ok = false;
			try {
				collidingMemoryBlock.setWrite(isWritable);
				collidingMemoryBlock.setComment("Changed by SVD");
				ok = true;
			} catch (IllegalArgumentException e) {
				e.printStackTrace();
			}
			mProgram.endTransaction(transactionId, ok);
		}

		if (collidingMemoryBlock.isExecute() != isExecutable && OptionDialog.showYesNoDialog(null, "Load SVD",
				"Memory block \"" + collidingMemoryBlock.getName() + "\" is marked as"
						+ ((!collidingMemoryBlock.isExecute()) ? " non" : "")
						+ " executable. The SVD file suggests it should be"
						+ (collidingMemoryBlock.isExecute() ? " non" : "") + " executable. Do you want to change it to"
						+ (collidingMemoryBlock.isExecute() ? " non" : "")
						+ " executable?") == OptionDialog.OPTION_ONE) {
			int transactionId = mProgram
					.startTransaction("SVD " + collidingMemoryBlock.getName() + " memory block property change");
			boolean ok = false;
			try {
				collidingMemoryBlock.setExecute(isExecutable);
				collidingMemoryBlock.setComment("Changed by SVD");
				ok = true;
			} catch (IllegalArgumentException e) {
				e.printStackTrace();
			}
			mProgram.endTransaction(transactionId, ok);
		}

		if (collidingMemoryBlock.isVolatile() != isVolatile && OptionDialog.showYesNoDialog(null, "Load SVD",
				"Memory block \"" + collidingMemoryBlock.getName() + "\" is marked as"
						+ ((!collidingMemoryBlock.isVolatile()) ? " non" : "")
						+ " volatile. The SVD file suggests it should be"
						+ (collidingMemoryBlock.isVolatile() ? " non" : "") + " volatile. Do you want to change it to"
						+ (collidingMemoryBlock.isVolatile() ? " non" : "")
						+ " volatile?") == OptionDialog.OPTION_ONE) {
			int transactionId = mProgram
					.startTransaction("SVD " + collidingMemoryBlock.getName() + " memory block property change");
			boolean ok = false;
			try {
				collidingMemoryBlock.setVolatile(isVolatile);
				collidingMemoryBlock.setComment("Changed by SVD");
				ok = true;
			} catch (IllegalArgumentException e) {
				e.printStackTrace();
			}
			mProgram.endTransaction(transactionId, ok);
		}
	}
}